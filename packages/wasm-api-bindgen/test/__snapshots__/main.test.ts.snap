// Bun Snapshot v1, https://goo.gl/fbAQLP

exports[`stringSlice 1`] = `
"#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <stdalign.h>
#include "wasmapi.h"


typedef struct WASM_Foo WASM_Foo;

struct WASM_Foo {
    WASM_String single;
    WASM_ConstString constSingle;
    WASM_ConstString multi[2];
    WASM_ConstString* singlePtr;
    WASM_ConstString* multiPtr;
    WASM_StringSlice slice;
    WASM_ConstStringSlice constSlice;
};

size_t __attribute__((used)) WASM_Foo_align() {
    return alignof(WASM_Foo);
}

size_t __attribute__((used)) WASM_Foo_size() {
    return sizeof(WASM_Foo);
}

size_t __attribute__((used)) WASM_Foo_single_align() {
    return alignof(WASM_String);
}

size_t __attribute__((used)) WASM_Foo_single_offset() {
    return offsetof(WASM_Foo, single);
}

size_t __attribute__((used)) WASM_Foo_single_size() {
    return sizeof(WASM_String);
}

size_t __attribute__((used)) WASM_Foo_constSingle_align() {
    return alignof(WASM_ConstString);
}

size_t __attribute__((used)) WASM_Foo_constSingle_offset() {
    return offsetof(WASM_Foo, constSingle);
}

size_t __attribute__((used)) WASM_Foo_constSingle_size() {
    return sizeof(WASM_ConstString);
}

size_t __attribute__((used)) WASM_Foo_multi_align() {
    return alignof(WASM_ConstString[2]);
}

size_t __attribute__((used)) WASM_Foo_multi_offset() {
    return offsetof(WASM_Foo, multi);
}

size_t __attribute__((used)) WASM_Foo_multi_size() {
    return sizeof(WASM_ConstString[2]);
}

size_t __attribute__((used)) WASM_Foo_singlePtr_align() {
    return alignof(WASM_ConstString*);
}

size_t __attribute__((used)) WASM_Foo_singlePtr_offset() {
    return offsetof(WASM_Foo, singlePtr);
}

size_t __attribute__((used)) WASM_Foo_singlePtr_size() {
    return sizeof(WASM_ConstString*);
}

size_t __attribute__((used)) WASM_Foo_multiPtr_align() {
    return alignof(WASM_ConstString*);
}

size_t __attribute__((used)) WASM_Foo_multiPtr_offset() {
    return offsetof(WASM_Foo, multiPtr);
}

size_t __attribute__((used)) WASM_Foo_multiPtr_size() {
    return sizeof(WASM_ConstString*);
}

size_t __attribute__((used)) WASM_Foo_slice_align() {
    return alignof(WASM_StringSlice);
}

size_t __attribute__((used)) WASM_Foo_slice_offset() {
    return offsetof(WASM_Foo, slice);
}

size_t __attribute__((used)) WASM_Foo_slice_size() {
    return sizeof(WASM_StringSlice);
}

size_t __attribute__((used)) WASM_Foo_constSlice_align() {
    return alignof(WASM_ConstStringSlice);
}

size_t __attribute__((used)) WASM_Foo_constSlice_offset() {
    return offsetof(WASM_Foo, constSlice);
}

size_t __attribute__((used)) WASM_Foo_constSlice_size() {
    return sizeof(WASM_ConstStringSlice);
}


#ifdef __cplusplus
}
#endif
"
`;

exports[`stringSlice 2`] = `
"// @ts-ignore possibly includes unused imports
import { Pointer, WasmStringSlice, type MemorySlice, type WasmTypeBase, type WasmTypeConstructor } from "@thi.ng/wasm-api";

export interface Foo extends WasmTypeBase {
	single: WasmStringSlice;
	constSingle: WasmStringSlice;
	multi: WasmStringSlice[];
	singlePtr: Pointer<WasmStringSlice>;
	multiPtr: Pointer<WasmStringSlice[]>;
	slice: WasmStringSlice[];
	constSlice: WasmStringSlice[];
}

export const $Foo: WasmTypeConstructor<Foo> = (mem) => ({
	get align() {
		return 4;
	},
	get size() {
		return 56;
	},
	instanceArray(base, num) {
		const items: Foo[] = [];
		for (; num --> 0; base += 56) items.push(this.instance(base));
		return items;
	},
	instance: (base) => {
		let $singlePtr: Pointer<WasmStringSlice> | null = null;
		let $multiPtr: Pointer<WasmStringSlice[]> | null = null;
		let $single: WasmStringSlice | null = null;
		let $constSingle: WasmStringSlice | null = null;
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 56);
			},
			get single(): WasmStringSlice {
				return $single || ($single = new WasmStringSlice(mem, base, false));
			},
			get constSingle(): WasmStringSlice {
				return $constSingle || ($constSingle = new WasmStringSlice(mem, (base + 8), true));
			},
			get multi(): WasmStringSlice[] {
				const addr = (base + 16);
				const $multi: WasmStringSlice[] = [];
				for(let i = 0; i < 2; i++) $multi.push(new WasmStringSlice(mem, addr + i * 8, true));
				return $multi;
			},
			get singlePtr(): Pointer<WasmStringSlice> {
				return $singlePtr || ($singlePtr = new Pointer<WasmStringSlice>(mem, (base + 32),
				(addr) => new WasmStringSlice(mem, addr, true)
				));
			},
			get multiPtr(): Pointer<WasmStringSlice[]> {
				return $multiPtr || ($multiPtr = new Pointer<WasmStringSlice[]>(mem, (base + 36),
				(addr) => {
					const $buf: WasmStringSlice[] = [];
					for(let i = 0; i < 2; i++) $buf.push(new WasmStringSlice(mem, addr + i * 8, true));
					return $buf;
				}
				));
			},
			get slice(): WasmStringSlice[] {
				const addr = mem.u32[(base + 40) >>> 2];
				const len = mem.u32[(base + 44) >>> 2];
				const $slice: WasmStringSlice[] = [];
				for(let i = 0; i < len; i++) $slice.push(new WasmStringSlice(mem, addr + i * 8, false));
				return $slice;
			},
			get constSlice(): WasmStringSlice[] {
				const addr = mem.u32[(base + 48) >>> 2];
				const len = mem.u32[(base + 52) >>> 2];
				const $constSlice: WasmStringSlice[] = [];
				for(let i = 0; i < len; i++) $constSlice.push(new WasmStringSlice(mem, addr + i * 8, true));
				return $constSlice;
			},
		};
	}
});
"
`;

exports[`stringSlice 3`] = `
"const std = @import("std");
const bindgen = @import("wasm-api-bindgen");

pub const Foo = extern struct {
    single: bindgen.String,
    constSingle: bindgen.ConstString,
    multi: [2]bindgen.ConstString,
    singlePtr: *bindgen.ConstString,
    multiPtr: *[2]bindgen.ConstString,
    slice: bindgen.StringSlice,
    constSlice: bindgen.ConstStringSlice,
};

export fn Foo_align() usize {
    return @alignOf(Foo);
}

export fn Foo_size() usize {
    return @sizeOf(Foo);
}

export fn Foo_single_align() usize {
    return @alignOf(bindgen.String);
}

export fn Foo_single_offset() usize {
    return @offsetOf(Foo, "single");
}

export fn Foo_single_size() usize {
    return @sizeOf(bindgen.String);
}

export fn Foo_constSingle_align() usize {
    return @alignOf(bindgen.ConstString);
}

export fn Foo_constSingle_offset() usize {
    return @offsetOf(Foo, "constSingle");
}

export fn Foo_constSingle_size() usize {
    return @sizeOf(bindgen.ConstString);
}

export fn Foo_multi_align() usize {
    return @alignOf([2]bindgen.ConstString);
}

export fn Foo_multi_offset() usize {
    return @offsetOf(Foo, "multi");
}

export fn Foo_multi_size() usize {
    return @sizeOf([2]bindgen.ConstString);
}

export fn Foo_singlePtr_align() usize {
    return @alignOf(*bindgen.ConstString);
}

export fn Foo_singlePtr_offset() usize {
    return @offsetOf(Foo, "singlePtr");
}

export fn Foo_singlePtr_size() usize {
    return @sizeOf(*bindgen.ConstString);
}

export fn Foo_multiPtr_align() usize {
    return @alignOf(*[2]bindgen.ConstString);
}

export fn Foo_multiPtr_offset() usize {
    return @offsetOf(Foo, "multiPtr");
}

export fn Foo_multiPtr_size() usize {
    return @sizeOf(*[2]bindgen.ConstString);
}

export fn Foo_slice_align() usize {
    return @alignOf(bindgen.StringSlice);
}

export fn Foo_slice_offset() usize {
    return @offsetOf(Foo, "slice");
}

export fn Foo_slice_size() usize {
    return @sizeOf(bindgen.StringSlice);
}

export fn Foo_constSlice_align() usize {
    return @alignOf(bindgen.ConstStringSlice);
}

export fn Foo_constSlice_offset() usize {
    return @offsetOf(Foo, "constSlice");
}

export fn Foo_constSlice_size() usize {
    return @sizeOf(bindgen.ConstStringSlice);
}
"
`;

exports[`stringPtr 1`] = `
"#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <stdalign.h>
#include "wasmapi.h"


typedef struct WASM_Foo WASM_Foo;

struct WASM_Foo {
    WASM_StringPtr single;
    WASM_ConstStringPtr constSingle;
    WASM_ConstStringPtr multi[2];
    WASM_ConstStringPtr* singlePtr;
    WASM_ConstStringPtr* multiPtr;
    WASM_StringPtrSlice slice;
    WASM_ConstStringPtrSlice constSlice;
};

size_t __attribute__((used)) WASM_Foo_align() {
    return alignof(WASM_Foo);
}

size_t __attribute__((used)) WASM_Foo_size() {
    return sizeof(WASM_Foo);
}

size_t __attribute__((used)) WASM_Foo_single_align() {
    return alignof(WASM_StringPtr);
}

size_t __attribute__((used)) WASM_Foo_single_offset() {
    return offsetof(WASM_Foo, single);
}

size_t __attribute__((used)) WASM_Foo_single_size() {
    return sizeof(WASM_StringPtr);
}

size_t __attribute__((used)) WASM_Foo_constSingle_align() {
    return alignof(WASM_ConstStringPtr);
}

size_t __attribute__((used)) WASM_Foo_constSingle_offset() {
    return offsetof(WASM_Foo, constSingle);
}

size_t __attribute__((used)) WASM_Foo_constSingle_size() {
    return sizeof(WASM_ConstStringPtr);
}

size_t __attribute__((used)) WASM_Foo_multi_align() {
    return alignof(WASM_ConstStringPtr[2]);
}

size_t __attribute__((used)) WASM_Foo_multi_offset() {
    return offsetof(WASM_Foo, multi);
}

size_t __attribute__((used)) WASM_Foo_multi_size() {
    return sizeof(WASM_ConstStringPtr[2]);
}

size_t __attribute__((used)) WASM_Foo_singlePtr_align() {
    return alignof(WASM_ConstStringPtr*);
}

size_t __attribute__((used)) WASM_Foo_singlePtr_offset() {
    return offsetof(WASM_Foo, singlePtr);
}

size_t __attribute__((used)) WASM_Foo_singlePtr_size() {
    return sizeof(WASM_ConstStringPtr*);
}

size_t __attribute__((used)) WASM_Foo_multiPtr_align() {
    return alignof(WASM_ConstStringPtr*);
}

size_t __attribute__((used)) WASM_Foo_multiPtr_offset() {
    return offsetof(WASM_Foo, multiPtr);
}

size_t __attribute__((used)) WASM_Foo_multiPtr_size() {
    return sizeof(WASM_ConstStringPtr*);
}

size_t __attribute__((used)) WASM_Foo_slice_align() {
    return alignof(WASM_StringPtrSlice);
}

size_t __attribute__((used)) WASM_Foo_slice_offset() {
    return offsetof(WASM_Foo, slice);
}

size_t __attribute__((used)) WASM_Foo_slice_size() {
    return sizeof(WASM_StringPtrSlice);
}

size_t __attribute__((used)) WASM_Foo_constSlice_align() {
    return alignof(WASM_ConstStringPtrSlice);
}

size_t __attribute__((used)) WASM_Foo_constSlice_offset() {
    return offsetof(WASM_Foo, constSlice);
}

size_t __attribute__((used)) WASM_Foo_constSlice_size() {
    return sizeof(WASM_ConstStringPtrSlice);
}


#ifdef __cplusplus
}
#endif
"
`;

exports[`stringPtr 2`] = `
"// @ts-ignore possibly includes unused imports
import { Pointer, WasmStringPtr, type MemorySlice, type WasmTypeBase, type WasmTypeConstructor } from "@thi.ng/wasm-api";

export interface Foo extends WasmTypeBase {
	single: WasmStringPtr;
	constSingle: WasmStringPtr;
	multi: WasmStringPtr[];
	singlePtr: Pointer<WasmStringPtr>;
	multiPtr: Pointer<WasmStringPtr[]>;
	slice: WasmStringPtr[];
	constSlice: WasmStringPtr[];
}

export const $Foo: WasmTypeConstructor<Foo> = (mem) => ({
	get align() {
		return 4;
	},
	get size() {
		return 56;
	},
	instanceArray(base, num) {
		const items: Foo[] = [];
		for (; num --> 0; base += 56) items.push(this.instance(base));
		return items;
	},
	instance: (base) => {
		let $singlePtr: Pointer<WasmStringPtr> | null = null;
		let $multiPtr: Pointer<WasmStringPtr[]> | null = null;
		let $single: WasmStringPtr | null = null;
		let $constSingle: WasmStringPtr | null = null;
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 56);
			},
			get single(): WasmStringPtr {
				return $single || ($single = new WasmStringPtr(mem, base, false));
			},
			get constSingle(): WasmStringPtr {
				return $constSingle || ($constSingle = new WasmStringPtr(mem, (base + 8), true));
			},
			get multi(): WasmStringPtr[] {
				const addr = (base + 16);
				const $multi: WasmStringPtr[] = [];
				for(let i = 0; i < 2; i++) $multi.push(new WasmStringPtr(mem, addr + i * 4, true));
				return $multi;
			},
			get singlePtr(): Pointer<WasmStringPtr> {
				return $singlePtr || ($singlePtr = new Pointer<WasmStringPtr>(mem, (base + 32),
				(addr) => new WasmStringPtr(mem, addr, true)
				));
			},
			get multiPtr(): Pointer<WasmStringPtr[]> {
				return $multiPtr || ($multiPtr = new Pointer<WasmStringPtr[]>(mem, (base + 36),
				(addr) => {
					const $buf: WasmStringPtr[] = [];
					for(let i = 0; i < 2; i++) $buf.push(new WasmStringPtr(mem, addr + i * 4, true));
					return $buf;
				}
				));
			},
			get slice(): WasmStringPtr[] {
				const addr = mem.u32[(base + 40) >>> 2];
				const len = mem.u32[(base + 44) >>> 2];
				const $slice: WasmStringPtr[] = [];
				for(let i = 0; i < len; i++) $slice.push(new WasmStringPtr(mem, addr + i * 4, false));
				return $slice;
			},
			get constSlice(): WasmStringPtr[] {
				const addr = mem.u32[(base + 48) >>> 2];
				const len = mem.u32[(base + 52) >>> 2];
				const $constSlice: WasmStringPtr[] = [];
				for(let i = 0; i < len; i++) $constSlice.push(new WasmStringPtr(mem, addr + i * 4, true));
				return $constSlice;
			},
		};
	}
});
"
`;

exports[`stringPtr 3`] = `
"const std = @import("std");
const bindgen = @import("wasm-api-bindgen");

pub const Foo = extern struct {
    single: bindgen.StringPtr,
    constSingle: bindgen.ConstStringPtr,
    multi: [2]bindgen.ConstStringPtr,
    singlePtr: *bindgen.ConstStringPtr,
    multiPtr: *[2]bindgen.ConstStringPtr,
    slice: bindgen.StringPtrSlice,
    constSlice: bindgen.ConstStringPtrSlice,
};

export fn Foo_align() usize {
    return @alignOf(Foo);
}

export fn Foo_size() usize {
    return @sizeOf(Foo);
}

export fn Foo_single_align() usize {
    return @alignOf(bindgen.StringPtr);
}

export fn Foo_single_offset() usize {
    return @offsetOf(Foo, "single");
}

export fn Foo_single_size() usize {
    return @sizeOf(bindgen.StringPtr);
}

export fn Foo_constSingle_align() usize {
    return @alignOf(bindgen.ConstStringPtr);
}

export fn Foo_constSingle_offset() usize {
    return @offsetOf(Foo, "constSingle");
}

export fn Foo_constSingle_size() usize {
    return @sizeOf(bindgen.ConstStringPtr);
}

export fn Foo_multi_align() usize {
    return @alignOf([2]bindgen.ConstStringPtr);
}

export fn Foo_multi_offset() usize {
    return @offsetOf(Foo, "multi");
}

export fn Foo_multi_size() usize {
    return @sizeOf([2]bindgen.ConstStringPtr);
}

export fn Foo_singlePtr_align() usize {
    return @alignOf(*bindgen.ConstStringPtr);
}

export fn Foo_singlePtr_offset() usize {
    return @offsetOf(Foo, "singlePtr");
}

export fn Foo_singlePtr_size() usize {
    return @sizeOf(*bindgen.ConstStringPtr);
}

export fn Foo_multiPtr_align() usize {
    return @alignOf(*[2]bindgen.ConstStringPtr);
}

export fn Foo_multiPtr_offset() usize {
    return @offsetOf(Foo, "multiPtr");
}

export fn Foo_multiPtr_size() usize {
    return @sizeOf(*[2]bindgen.ConstStringPtr);
}

export fn Foo_slice_align() usize {
    return @alignOf(bindgen.StringPtrSlice);
}

export fn Foo_slice_offset() usize {
    return @offsetOf(Foo, "slice");
}

export fn Foo_slice_size() usize {
    return @sizeOf(bindgen.StringPtrSlice);
}

export fn Foo_constSlice_align() usize {
    return @alignOf(bindgen.ConstStringPtrSlice);
}

export fn Foo_constSlice_offset() usize {
    return @offsetOf(Foo, "constSlice");
}

export fn Foo_constSlice_size() usize {
    return @sizeOf(bindgen.ConstStringPtrSlice);
}
"
`;

exports[`union 1`] = `
"#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include "wasmapi.h"


typedef struct WASM_A WASM_A;

typedef union WASM_B WASM_B;

struct WASM_A {
    uint8_t a;
    uint8_t __pad0[3];
    uint32_t b;
    uint16_t* c;
    uint8_t __pad1[2];
    double d;
};

union WASM_B {
    WASM_A a[3];
    uint64_t b;
};


#ifdef __cplusplus
}
#endif
"
`;

exports[`union 2`] = `
"// @ts-ignore possibly includes unused imports
import { Pointer, WasmStringPtr, type MemorySlice, type WasmTypeBase, type WasmTypeConstructor } from "@thi.ng/wasm-api";

export interface A extends WasmTypeBase {
	/**
	 * Zig type: \`u8\`
	 */
	a: number;
	/**
	 * Zig type: \`u32\`
	 */
	b: number;
	/**
	 * Zig type: \`*[3]u16\`
	 */
	c: Pointer<Uint16Array>;
	/**
	 * Zig type: \`f64\`
	 */
	d: number;
}

export const $A: WasmTypeConstructor<A> = (mem) => ({
	get align() {
		return 8;
	},
	get size() {
		return 24;
	},
	instanceArray(base, num) {
		const items: A[] = [];
		for (; num --> 0; base += 24) items.push(this.instance(base));
		return items;
	},
	instance: (base) => {
		let $c: Pointer<Uint16Array> | null = null;
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 24);
			},
			get a(): number {
				return mem.u8[base];
			},
			set a(x: number) {
				mem.u8[base] = x;
			},
			get b(): number {
				return mem.u32[(base + 4) >>> 2];
			},
			set b(x: number) {
				mem.u32[(base + 4) >>> 2] = x;
			},
			get c(): Pointer<Uint16Array> {
				return $c || ($c = new Pointer<Uint16Array>(mem, (base + 8),
				(addr) => mem.u16.subarray(addr, addr + 3)
				));
			},
			get d(): number {
				return mem.f64[(base + 16) >>> 3];
			},
			set d(x: number) {
				mem.f64[(base + 16) >>> 3] = x;
			},
		};
	}
});

export interface B extends WasmTypeBase {
	a: A[];
	/**
	 * Zig type: \`u64\`
	 */
	b: bigint;
}

export const $B: WasmTypeConstructor<B> = (mem) => ({
	get align() {
		return 8;
	},
	get size() {
		return 72;
	},
	instanceArray(base, num) {
		const items: B[] = [];
		for (; num --> 0; base += 72) items.push(this.instance(base));
		return items;
	},
	instance: (base) => {
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 72);
			},
			get a(): A[] {
				const addr = base;
				const inst = $A(mem);
				const buf: A[] = [];
				for(let i = 0; i < 3; i++) buf.push(inst.instance(addr + i * 24));
				return buf;
			},
			get b(): bigint {
				return mem.u64[base >>> 3];
			},
			set b(x: bigint) {
				mem.u64[base >>> 3] = x;
			},
		};
	}
});
"
`;

exports[`union 3`] = `
"const std = @import("std");
const bindgen = @import("wasm-api-bindgen");

pub const A = extern struct {
    a: u8,
    __pad0: [3]u8,
    b: u32,
    c: *[3]u16,
    __pad1: [2]u8,
    d: f64,
};

pub const B = extern union {
    a: [3]A,
    b: u64,
};
"
`;

exports[`opaque 1`] = `
"#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include "wasmapi.h"


typedef struct WASM_A WASM_A;

struct WASM_A {
    WASM_OpaquePtr a;
    WASM_OpaquePtr* ptr;
    WASM_OpaquePtr* ptr2;
    WASM_ConstOpaquePtr* constPtr;
    WASM_OpaquePtrSlice slice;
    WASM_ConstOpaquePtrSlice constSlice;
    WASM_OpaquePtr array[3];
    WASM_ConstOpaquePtr constArray[3];
};


#ifdef __cplusplus
}
#endif
"
`;

exports[`opaque 2`] = `
"// @ts-ignore possibly includes unused imports
import { Pointer, WasmStringPtr, type MemorySlice, type WasmTypeBase, type WasmTypeConstructor } from "@thi.ng/wasm-api";

export interface A extends WasmTypeBase {
	/**
	 * Zig type: \`u32\`
	 */
	a: number;
	/**
	 * Zig type: \`*u32\`
	 */
	ptr: Pointer<number>;
	/**
	 * Zig type: \`*[2]u32\`
	 */
	ptr2: Pointer<Uint32Array>;
	/**
	 * Zig type: \`*const u32\`
	 */
	constPtr: Pointer<number>;
	/**
	 * Zig type: \`U32Slice\`
	 */
	slice: Uint32Array;
	/**
	 * Zig type: \`ConstU32Slice\`
	 */
	constSlice: Uint32Array;
	/**
	 * Zig type: \`[3]u32\`
	 */
	array: Uint32Array;
	/**
	 * Zig type: \`[3]u32\`
	 */
	constArray: Uint32Array;
}

export const $A: WasmTypeConstructor<A> = (mem) => ({
	get align() {
		return 4;
	},
	get size() {
		return 56;
	},
	instanceArray(base, num) {
		const items: A[] = [];
		for (; num --> 0; base += 56) items.push(this.instance(base));
		return items;
	},
	instance: (base) => {
		let $ptr: Pointer<number> | null = null;
		let $ptr2: Pointer<Uint32Array> | null = null;
		let $constPtr: Pointer<number> | null = null;
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 56);
			},
			get a(): number {
				return mem.u32[base >>> 2];
			},
			set a(x: number) {
				mem.u32[base >>> 2] = x;
			},
			get ptr(): Pointer<number> {
				return $ptr || ($ptr = new Pointer<number>(mem, (base + 4),
				(addr) => mem.u32[addr >>> 2]
				));
			},
			get ptr2(): Pointer<Uint32Array> {
				return $ptr2 || ($ptr2 = new Pointer<Uint32Array>(mem, (base + 8),
				(addr) => mem.u32.subarray(addr, addr + 2)
				));
			},
			get constPtr(): Pointer<number> {
				return $constPtr || ($constPtr = new Pointer<number>(mem, (base + 12),
				(addr) => mem.u32[addr >>> 2]
				));
			},
			get slice(): Uint32Array {
				const addr = mem.u32[(base + 16) >>> 2];
				const len = mem.u32[(base + 20) >>> 2];
				return mem.u32.subarray(addr, addr + len);
			},
			get constSlice(): Uint32Array {
				const addr = mem.u32[(base + 24) >>> 2];
				const len = mem.u32[(base + 28) >>> 2];
				return mem.u32.subarray(addr, addr + len);
			},
			get array(): Uint32Array {
				const addr = (base + 32) >>> 2;
				return mem.u32.subarray(addr, addr + 3);
			},
			get constArray(): Uint32Array {
				const addr = (base + 44) >>> 2;
				return mem.u32.subarray(addr, addr + 3);
			},
		};
	}
});
"
`;

exports[`opaque 3`] = `
"const std = @import("std");
const bindgen = @import("wasm-api-bindgen");

pub const A = extern struct {
    a: bindgen.OpaquePtr,
    ptr: *bindgen.OpaquePtr,
    ptr2: *[2]bindgen.OpaquePtr,
    constPtr: *bindgen.ConstOpaquePtr,
    slice: bindgen.OpaquePtrSlice,
    constSlice: bindgen.ConstOpaquePtrSlice,
    array: [3]bindgen.OpaquePtr,
    constArray: [3]bindgen.ConstOpaquePtr,
};
"
`;

exports[`enum 1`] = `
"#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include "wasmapi.h"


typedef enum WASM_A WASM_A;

typedef struct { WASM_A* ptr; size_t len; } WASM_ASlice;
typedef struct { const WASM_A* ptr; size_t len; } WASM_ConstASlice;

typedef struct WASM_B WASM_B;

enum WASM_A {
    FOO,
    BAR,
    BAZ = 10,
};

struct WASM_B {
    WASM_A single;
    WASM_A array[2];
    WASM_ASlice slice;
    WASM_A* ptr;
    WASM_A* ptr2;
};


#ifdef __cplusplus
}
#endif
"
`;

exports[`enum 2`] = `
"// @ts-ignore possibly includes unused imports
import { Pointer, WasmStringPtr, type MemorySlice, type WasmTypeBase, type WasmTypeConstructor } from "@thi.ng/wasm-api";

export enum A {
	FOO,
	BAR,
	BAZ = 10,
}

export interface B extends WasmTypeBase {
	single: A;
	array: Int32Array;
	slice: Int32Array;
	ptr: Pointer<A>;
	ptr2: Pointer<Int32Array>;
}

export const $B: WasmTypeConstructor<B> = (mem) => ({
	get align() {
		return 4;
	},
	get size() {
		return 28;
	},
	instanceArray(base, num) {
		const items: B[] = [];
		for (; num --> 0; base += 28) items.push(this.instance(base));
		return items;
	},
	instance: (base) => {
		let $ptr: Pointer<A> | null = null;
		let $ptr2: Pointer<Int32Array> | null = null;
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 28);
			},
			get single(): A {
				return mem.i32[base >>> 2];
			},
			set single(x: A) {
				mem.i32[base >>> 2] = x;
			},
			get array(): Int32Array {
				const addr = (base + 4) >>> 2;
				return mem.i32.subarray(addr, addr + 2);
			},
			get slice(): Int32Array {
				const addr = mem.u32[(base + 12) >>> 2];
				const len = mem.u32[(base + 16) >>> 2];
				return mem.i32.subarray(addr, addr + len);
			},
			get ptr(): Pointer<A> {
				return $ptr || ($ptr = new Pointer<A>(mem, (base + 20),
				(addr) => mem.i32[addr >>> 2]
				));
			},
			get ptr2(): Pointer<Int32Array> {
				return $ptr2 || ($ptr2 = new Pointer<Int32Array>(mem, (base + 24),
				(addr) => mem.i32.subarray(addr, addr + 2)
				));
			},
		};
	}
});
"
`;

exports[`enum 3`] = `
"const std = @import("std");
const bindgen = @import("wasm-api-bindgen");

pub const ASlice = bindgen.Slice([]A, [*]A);
pub const ConstASlice = bindgen.Slice([]const A, [*]const A);

pub const A = enum(i32) {
    foo,
    bar,
    baz = 10,
};

pub const B = extern struct {
    single: A,
    array: [2]A,
    slice: ASlice,
    ptr: *A,
    ptr2: *[2]A,
};
"
`;

exports[`funcptr 1`] = `
"#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include "wasmapi.h"

typedef void (*WASM_A)(uint32_t* x, WASM_ConstStringPtr y);

typedef struct { WASM_A* ptr; size_t len; } WASM_ASlice;
typedef struct { const WASM_A* ptr; size_t len; } WASM_ConstASlice;

typedef struct WASM_B WASM_B;

struct WASM_B {
    WASM_A a;
    WASM_A* ptr;
    WASM_A* ptr2;
    WASM_A array[2];
    WASM_ASlice slice;
};


#ifdef __cplusplus
}
#endif
"
`;

exports[`funcptr 2`] = `
"// @ts-ignore possibly includes unused imports
import { Pointer, WasmStringPtr, type MemorySlice, type WasmTypeBase, type WasmTypeConstructor } from "@thi.ng/wasm-api";

export interface B extends WasmTypeBase {
	/**
	 * Zig type: \`u32\`
	 */
	a: number;
	/**
	 * Zig type: \`*u32\`
	 */
	ptr: Pointer<number>;
	/**
	 * Zig type: \`*[2]u32\`
	 */
	ptr2: Pointer<Uint32Array>;
	/**
	 * Zig type: \`[2]u32\`
	 */
	array: Uint32Array;
	/**
	 * Zig type: \`U32Slice\`
	 */
	slice: Uint32Array;
}

export const $B: WasmTypeConstructor<B> = (mem) => ({
	get align() {
		return 4;
	},
	get size() {
		return 28;
	},
	instanceArray(base, num) {
		const items: B[] = [];
		for (; num --> 0; base += 28) items.push(this.instance(base));
		return items;
	},
	instance: (base) => {
		let $ptr: Pointer<number> | null = null;
		let $ptr2: Pointer<Uint32Array> | null = null;
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 28);
			},
			get a(): number {
				return mem.u32[base >>> 2];
			},
			set a(x: number) {
				mem.u32[base >>> 2] = x;
			},
			get ptr(): Pointer<number> {
				return $ptr || ($ptr = new Pointer<number>(mem, (base + 4),
				(addr) => mem.u32[addr >>> 2]
				));
			},
			get ptr2(): Pointer<Uint32Array> {
				return $ptr2 || ($ptr2 = new Pointer<Uint32Array>(mem, (base + 8),
				(addr) => mem.u32.subarray(addr, addr + 2)
				));
			},
			get array(): Uint32Array {
				const addr = (base + 12) >>> 2;
				return mem.u32.subarray(addr, addr + 2);
			},
			get slice(): Uint32Array {
				const addr = mem.u32[(base + 20) >>> 2];
				const len = mem.u32[(base + 24) >>> 2];
				return mem.u32.subarray(addr, addr + len);
			},
		};
	}
});
"
`;

exports[`funcptr 3`] = `
"const std = @import("std");
const bindgen = @import("wasm-api-bindgen");

pub const ASlice = bindgen.Slice([]A, [*]A);
pub const ConstASlice = bindgen.Slice([]const A, [*]const A);

pub const A = *const fn (x: *u32, y: bindgen.ConstStringPtr) void;

pub const B = extern struct {
    a: A,
    ptr: *A,
    ptr2: *[2]A,
    array: [2]A,
    slice: ASlice,
};
"
`;

exports[`slices 1`] = `
"#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <stdalign.h>
#include "wasmapi.h"


typedef struct { uint8_t* ptr; size_t len; } WASM_U8Slice;
typedef struct { const uint8_t* ptr; size_t len; } WASM_ConstU8Slice;

typedef struct WASM_A WASM_A;

typedef struct { WASM_A* ptr; size_t len; } WASM_ASlice;
typedef struct { const WASM_A* ptr; size_t len; } WASM_ConstASlice;

typedef struct WASM_B WASM_B;

struct WASM_A {
    uint16_t a;
};

size_t __attribute__((used)) WASM_A_align() {
    return alignof(WASM_A);
}

size_t __attribute__((used)) WASM_A_size() {
    return sizeof(WASM_A);
}

size_t __attribute__((used)) WASM_A_a_align() {
    return alignof(uint16_t);
}

size_t __attribute__((used)) WASM_A_a_offset() {
    return offsetof(WASM_A, a);
}

size_t __attribute__((used)) WASM_A_a_size() {
    return sizeof(uint16_t);
}

struct WASM_B {
    WASM_U8Slice slice;
    WASM_ConstU8Slice constSlice;
    uint8_t* ptr;
    const uint8_t* constPtr;
    uint8_t* ptr2;
    uint8_t* ptr2sentinel;
    const uint8_t* constPtr2;
    const uint8_t* constPtr2sentinel;
    uint8_t* ptrMulti;
    uint8_t* ptrMultiSentinel;
    const uint8_t* constPtrMulti;
    const uint8_t* constPtrMultiSentinel;
    int32_t array[2];
    int32_t arraySentinel[2];
    // Hidden sentinel. Must be manually initialized to 0
    int32_t __arraySentinelSentinel;
    WASM_A aSingle;
    WASM_ASlice aSlice;
    WASM_ConstASlice constASlice;
    WASM_A* aPtr;
    WASM_A* aPtr2;
    // Multiple A's
    WASM_A* aPtrMulti;
};

size_t __attribute__((used)) WASM_B_align() {
    return alignof(WASM_B);
}

size_t __attribute__((used)) WASM_B_size() {
    return sizeof(WASM_B);
}

size_t __attribute__((used)) WASM_B_slice_align() {
    return alignof(WASM_U8Slice);
}

size_t __attribute__((used)) WASM_B_slice_offset() {
    return offsetof(WASM_B, slice);
}

size_t __attribute__((used)) WASM_B_slice_size() {
    return sizeof(WASM_U8Slice);
}

size_t __attribute__((used)) WASM_B_constSlice_align() {
    return alignof(WASM_ConstU8Slice);
}

size_t __attribute__((used)) WASM_B_constSlice_offset() {
    return offsetof(WASM_B, constSlice);
}

size_t __attribute__((used)) WASM_B_constSlice_size() {
    return sizeof(WASM_ConstU8Slice);
}

size_t __attribute__((used)) WASM_B_ptr_align() {
    return alignof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptr_offset() {
    return offsetof(WASM_B, ptr);
}

size_t __attribute__((used)) WASM_B_ptr_size() {
    return sizeof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtr_align() {
    return alignof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtr_offset() {
    return offsetof(WASM_B, constPtr);
}

size_t __attribute__((used)) WASM_B_constPtr_size() {
    return sizeof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptr2_align() {
    return alignof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptr2_offset() {
    return offsetof(WASM_B, ptr2);
}

size_t __attribute__((used)) WASM_B_ptr2_size() {
    return sizeof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptr2sentinel_align() {
    return alignof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptr2sentinel_offset() {
    return offsetof(WASM_B, ptr2sentinel);
}

size_t __attribute__((used)) WASM_B_ptr2sentinel_size() {
    return sizeof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtr2_align() {
    return alignof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtr2_offset() {
    return offsetof(WASM_B, constPtr2);
}

size_t __attribute__((used)) WASM_B_constPtr2_size() {
    return sizeof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtr2sentinel_align() {
    return alignof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtr2sentinel_offset() {
    return offsetof(WASM_B, constPtr2sentinel);
}

size_t __attribute__((used)) WASM_B_constPtr2sentinel_size() {
    return sizeof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptrMulti_align() {
    return alignof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptrMulti_offset() {
    return offsetof(WASM_B, ptrMulti);
}

size_t __attribute__((used)) WASM_B_ptrMulti_size() {
    return sizeof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptrMultiSentinel_align() {
    return alignof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_ptrMultiSentinel_offset() {
    return offsetof(WASM_B, ptrMultiSentinel);
}

size_t __attribute__((used)) WASM_B_ptrMultiSentinel_size() {
    return sizeof(uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtrMulti_align() {
    return alignof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtrMulti_offset() {
    return offsetof(WASM_B, constPtrMulti);
}

size_t __attribute__((used)) WASM_B_constPtrMulti_size() {
    return sizeof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtrMultiSentinel_align() {
    return alignof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_constPtrMultiSentinel_offset() {
    return offsetof(WASM_B, constPtrMultiSentinel);
}

size_t __attribute__((used)) WASM_B_constPtrMultiSentinel_size() {
    return sizeof(const uint8_t*);
}

size_t __attribute__((used)) WASM_B_array_align() {
    return alignof(int32_t[2]);
}

size_t __attribute__((used)) WASM_B_array_offset() {
    return offsetof(WASM_B, array);
}

size_t __attribute__((used)) WASM_B_array_size() {
    return sizeof(int32_t[2]);
}

size_t __attribute__((used)) WASM_B_arraySentinel_align() {
    return alignof(int32_t[2]);
}

size_t __attribute__((used)) WASM_B_arraySentinel_offset() {
    return offsetof(WASM_B, arraySentinel);
}

size_t __attribute__((used)) WASM_B_arraySentinel_size() {
    return sizeof(int32_t[2]);
}

size_t __attribute__((used)) WASM_B_aSingle_align() {
    return alignof(WASM_A);
}

size_t __attribute__((used)) WASM_B_aSingle_offset() {
    return offsetof(WASM_B, aSingle);
}

size_t __attribute__((used)) WASM_B_aSingle_size() {
    return sizeof(WASM_A);
}

size_t __attribute__((used)) WASM_B_aSlice_align() {
    return alignof(WASM_ASlice);
}

size_t __attribute__((used)) WASM_B_aSlice_offset() {
    return offsetof(WASM_B, aSlice);
}

size_t __attribute__((used)) WASM_B_aSlice_size() {
    return sizeof(WASM_ASlice);
}

size_t __attribute__((used)) WASM_B_constASlice_align() {
    return alignof(WASM_ConstASlice);
}

size_t __attribute__((used)) WASM_B_constASlice_offset() {
    return offsetof(WASM_B, constASlice);
}

size_t __attribute__((used)) WASM_B_constASlice_size() {
    return sizeof(WASM_ConstASlice);
}

size_t __attribute__((used)) WASM_B_aPtr_align() {
    return alignof(WASM_A*);
}

size_t __attribute__((used)) WASM_B_aPtr_offset() {
    return offsetof(WASM_B, aPtr);
}

size_t __attribute__((used)) WASM_B_aPtr_size() {
    return sizeof(WASM_A*);
}

size_t __attribute__((used)) WASM_B_aPtr2_align() {
    return alignof(WASM_A*);
}

size_t __attribute__((used)) WASM_B_aPtr2_offset() {
    return offsetof(WASM_B, aPtr2);
}

size_t __attribute__((used)) WASM_B_aPtr2_size() {
    return sizeof(WASM_A*);
}

size_t __attribute__((used)) WASM_B_aPtrMulti_align() {
    return alignof(WASM_A*);
}

size_t __attribute__((used)) WASM_B_aPtrMulti_offset() {
    return offsetof(WASM_B, aPtrMulti);
}

size_t __attribute__((used)) WASM_B_aPtrMulti_size() {
    return sizeof(WASM_A*);
}


#ifdef __cplusplus
}
#endif
"
`;

exports[`slices 2`] = `
"// @ts-ignore possibly includes unused imports
import { Pointer, WasmStringPtr, type MemorySlice, type WasmTypeBase, type WasmTypeConstructor } from "@thi.ng/wasm-api";

export interface A extends WasmTypeBase {
	/**
	 * Zig type: \`u16\`
	 */
	a: number;
}

export const $A: WasmTypeConstructor<A> = (mem) => ({
	get align() {
		return 2;
	},
	get size() {
		return 2;
	},
	instanceArray(base, num) {
		const items: A[] = [];
		for (; num --> 0; base += 2) items.push(this.instance(base));
		return items;
	},
	instance: (base) => {
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 2);
			},
			get a(): number {
				return mem.u16[base >>> 1];
			},
			set a(x: number) {
				mem.u16[base >>> 1] = x;
			},
		};
	}
});

export interface B extends WasmTypeBase {
	/**
	 * Zig type: \`U8Slice\`
	 */
	slice: Uint8Array;
	/**
	 * Zig type: \`ConstU8Slice\`
	 */
	constSlice: Uint8Array;
	/**
	 * Zig type: \`*u8\`
	 */
	ptr: Pointer<number>;
	/**
	 * Zig type: \`*const u8\`
	 */
	constPtr: Pointer<number>;
	/**
	 * Zig type: \`*[2]u8\`
	 */
	ptr2: Pointer<Uint8Array>;
	/**
	 * Zig type: \`*[2:0]u8\`
	 */
	ptr2sentinel: Pointer<Uint8Array>;
	/**
	 * Zig type: \`*const [2]u8\`
	 */
	constPtr2: Pointer<Uint8Array>;
	/**
	 * Zig type: \`*const [2:0]u8\`
	 */
	constPtr2sentinel: Pointer<Uint8Array>;
	/**
	 * Multi pointer: \`[*]u8\`
	 * 
	 * @remarks
	 * Only the pointer's target address can be accessed
	 */
	ptrMulti: number;
	/**
	 * Multi pointer: \`[*:255]u8\`
	 * 
	 * @remarks
	 * Only the pointer's target address can be accessed
	 */
	ptrMultiSentinel: number;
	/**
	 * Multi pointer: \`[*]const u8\`
	 * 
	 * @remarks
	 * Only the pointer's target address can be accessed
	 */
	constPtrMulti: number;
	/**
	 * Multi pointer: \`[*:255]const u8\`
	 * 
	 * @remarks
	 * Only the pointer's target address can be accessed
	 */
	constPtrMultiSentinel: number;
	/**
	 * Zig type: \`[2]i32\`
	 */
	array: Int32Array;
	/**
	 * Zig type: \`[2:0]i32\`
	 */
	arraySentinel: Int32Array;
	aSingle: A;
	aSlice: A[];
	constASlice: A[];
	aPtr: Pointer<A>;
	aPtr2: Pointer<A[]>;
	/**
	 * Multiple A's
	 * 
	 * @remarks
	 * Multi pointer: \`[*]A\`
	 * Only the pointer's target address can be accessed
	 */
	aPtrMulti: number;
}

export const $B: WasmTypeConstructor<B> = (mem) => ({
	get align() {
		return 4;
	},
	get size() {
		return 108;
	},
	instanceArray(base, num) {
		const items: B[] = [];
		for (; num --> 0; base += 108) items.push(this.instance(base));
		return items;
	},
	instance: (base) => {
		let $ptr: Pointer<number> | null = null;
		let $constPtr: Pointer<number> | null = null;
		let $ptr2: Pointer<Uint8Array> | null = null;
		let $ptr2sentinel: Pointer<Uint8Array> | null = null;
		let $constPtr2: Pointer<Uint8Array> | null = null;
		let $constPtr2sentinel: Pointer<Uint8Array> | null = null;
		let $aPtr: Pointer<A> | null = null;
		let $aPtr2: Pointer<A[]> | null = null;
		return {
			get __base() {
				return base;
			},
			get __bytes() {
				return mem.u8.subarray(base, base + 108);
			},
			get slice(): Uint8Array {
				const addr = mem.u32[base >>> 2];
				const len = mem.u32[(base + 4) >>> 2];
				return mem.u8.subarray(addr, addr + len);
			},
			get constSlice(): Uint8Array {
				const addr = mem.u32[(base + 8) >>> 2];
				const len = mem.u32[(base + 12) >>> 2];
				return mem.u8.subarray(addr, addr + len);
			},
			get ptr(): Pointer<number> {
				return $ptr || ($ptr = new Pointer<number>(mem, (base + 16),
				(addr) => mem.u8[addr >>> 0]
				));
			},
			get constPtr(): Pointer<number> {
				return $constPtr || ($constPtr = new Pointer<number>(mem, (base + 20),
				(addr) => mem.u8[addr >>> 0]
				));
			},
			get ptr2(): Pointer<Uint8Array> {
				return $ptr2 || ($ptr2 = new Pointer<Uint8Array>(mem, (base + 24),
				(addr) => mem.u8.subarray(addr, addr + 2)
				));
			},
			get ptr2sentinel(): Pointer<Uint8Array> {
				return $ptr2sentinel || ($ptr2sentinel = new Pointer<Uint8Array>(mem, (base + 28),
				(addr) => mem.u8.subarray(addr, addr + 2)
				));
			},
			get constPtr2(): Pointer<Uint8Array> {
				return $constPtr2 || ($constPtr2 = new Pointer<Uint8Array>(mem, (base + 32),
				(addr) => mem.u8.subarray(addr, addr + 2)
				));
			},
			get constPtr2sentinel(): Pointer<Uint8Array> {
				return $constPtr2sentinel || ($constPtr2sentinel = new Pointer<Uint8Array>(mem, (base + 36),
				(addr) => mem.u8.subarray(addr, addr + 2)
				));
			},
			get ptrMulti(): number {
				return mem.u32[(base + 40) >>> 2];
			},
			set ptrMulti(x: number) {
				mem.u32[(base + 40) >>> 2] = x;
			},
			get ptrMultiSentinel(): number {
				return mem.u32[(base + 44) >>> 2];
			},
			set ptrMultiSentinel(x: number) {
				mem.u32[(base + 44) >>> 2] = x;
			},
			get constPtrMulti(): number {
				return mem.u32[(base + 48) >>> 2];
			},
			set constPtrMulti(x: number) {
				mem.u32[(base + 48) >>> 2] = x;
			},
			get constPtrMultiSentinel(): number {
				return mem.u32[(base + 52) >>> 2];
			},
			set constPtrMultiSentinel(x: number) {
				mem.u32[(base + 52) >>> 2] = x;
			},
			get array(): Int32Array {
				const addr = (base + 56) >>> 2;
				return mem.i32.subarray(addr, addr + 2);
			},
			get arraySentinel(): Int32Array {
				const addr = (base + 64) >>> 2;
				return mem.i32.subarray(addr, addr + 2);
			},
			get aSingle(): A {
				return $A(mem).instance((base + 76));
			},
			set aSingle(x: A) {
				mem.u8.set(x.__bytes, (base + 76));
			},
			get aSlice(): A[] {
				const addr = mem.u32[(base + 80) >>> 2];
				const len = mem.u32[(base + 84) >>> 2];
				const inst = $A(mem);
				const buf: A[] = [];
				for(let i = 0; i < len; i++) buf.push(inst.instance(addr + i * 2));
				return buf;
			},
			get constASlice(): A[] {
				const addr = mem.u32[(base + 88) >>> 2];
				const len = mem.u32[(base + 92) >>> 2];
				const inst = $A(mem);
				const buf: A[] = [];
				for(let i = 0; i < len; i++) buf.push(inst.instance(addr + i * 2));
				return buf;
			},
			get aPtr(): Pointer<A> {
				return $aPtr || ($aPtr = new Pointer<A>(mem, (base + 96),
				(addr) => $A(mem).instance(addr)
				));
			},
			get aPtr2(): Pointer<A[]> {
				return $aPtr2 || ($aPtr2 = new Pointer<A[]>(mem, (base + 100),
				(addr) => {
					const inst = $A(mem);
					const buf: A[] = [];
					for(let i = 0; i < 2; i++) buf.push(inst.instance(addr + i * 2));
					return buf;
				}
				));
			},
			get aPtrMulti(): number {
				return mem.u32[(base + 104) >>> 2];
			},
			set aPtrMulti(x: number) {
				mem.u32[(base + 104) >>> 2] = x;
			},
		};
	}
});
"
`;

exports[`slices 3`] = `
"const std = @import("std");
const bindgen = @import("wasm-api-bindgen");

pub const U8Slice = bindgen.Slice([]u8, [*]u8);
pub const ConstU8Slice = bindgen.Slice([]const u8, [*]const u8);

pub const ASlice = bindgen.Slice([]A, [*]A);
pub const ConstASlice = bindgen.Slice([]const A, [*]const A);

pub const A = extern struct {
    a: u16,
};

export fn A_align() usize {
    return @alignOf(A);
}

export fn A_size() usize {
    return @sizeOf(A);
}

export fn A_a_align() usize {
    return @alignOf(u16);
}

export fn A_a_offset() usize {
    return @offsetOf(A, "a");
}

export fn A_a_size() usize {
    return @sizeOf(u16);
}

pub const B = extern struct {
    slice: U8Slice,
    constSlice: ConstU8Slice,
    ptr: *u8,
    constPtr: *const u8,
    ptr2: *[2]u8,
    ptr2sentinel: *[2:0]u8,
    constPtr2: *const [2]u8,
    constPtr2sentinel: *const [2:0]u8,
    ptrMulti: [*]u8,
    ptrMultiSentinel: [*:255]u8,
    constPtrMulti: [*]const u8,
    constPtrMultiSentinel: [*:255]const u8,
    array: [2]i32,
    arraySentinel: [2:0]i32,
    aSingle: A,
    aSlice: ASlice,
    constASlice: ConstASlice,
    aPtr: *A,
    aPtr2: *[2]A,
    /// Multiple A's
    aPtrMulti: [*]A,
};

export fn B_align() usize {
    return @alignOf(B);
}

export fn B_size() usize {
    return @sizeOf(B);
}

export fn B_slice_align() usize {
    return @alignOf(U8Slice);
}

export fn B_slice_offset() usize {
    return @offsetOf(B, "slice");
}

export fn B_slice_size() usize {
    return @sizeOf(U8Slice);
}

export fn B_constSlice_align() usize {
    return @alignOf(ConstU8Slice);
}

export fn B_constSlice_offset() usize {
    return @offsetOf(B, "constSlice");
}

export fn B_constSlice_size() usize {
    return @sizeOf(ConstU8Slice);
}

export fn B_ptr_align() usize {
    return @alignOf(*u8);
}

export fn B_ptr_offset() usize {
    return @offsetOf(B, "ptr");
}

export fn B_ptr_size() usize {
    return @sizeOf(*u8);
}

export fn B_constPtr_align() usize {
    return @alignOf(*const u8);
}

export fn B_constPtr_offset() usize {
    return @offsetOf(B, "constPtr");
}

export fn B_constPtr_size() usize {
    return @sizeOf(*const u8);
}

export fn B_ptr2_align() usize {
    return @alignOf(*[2]u8);
}

export fn B_ptr2_offset() usize {
    return @offsetOf(B, "ptr2");
}

export fn B_ptr2_size() usize {
    return @sizeOf(*[2]u8);
}

export fn B_ptr2sentinel_align() usize {
    return @alignOf(*[2:0]u8);
}

export fn B_ptr2sentinel_offset() usize {
    return @offsetOf(B, "ptr2sentinel");
}

export fn B_ptr2sentinel_size() usize {
    return @sizeOf(*[2:0]u8);
}

export fn B_constPtr2_align() usize {
    return @alignOf(*const [2]u8);
}

export fn B_constPtr2_offset() usize {
    return @offsetOf(B, "constPtr2");
}

export fn B_constPtr2_size() usize {
    return @sizeOf(*const [2]u8);
}

export fn B_constPtr2sentinel_align() usize {
    return @alignOf(*const [2:0]u8);
}

export fn B_constPtr2sentinel_offset() usize {
    return @offsetOf(B, "constPtr2sentinel");
}

export fn B_constPtr2sentinel_size() usize {
    return @sizeOf(*const [2:0]u8);
}

export fn B_ptrMulti_align() usize {
    return @alignOf([*]u8);
}

export fn B_ptrMulti_offset() usize {
    return @offsetOf(B, "ptrMulti");
}

export fn B_ptrMulti_size() usize {
    return @sizeOf([*]u8);
}

export fn B_ptrMultiSentinel_align() usize {
    return @alignOf([*:255]u8);
}

export fn B_ptrMultiSentinel_offset() usize {
    return @offsetOf(B, "ptrMultiSentinel");
}

export fn B_ptrMultiSentinel_size() usize {
    return @sizeOf([*:255]u8);
}

export fn B_constPtrMulti_align() usize {
    return @alignOf([*]const u8);
}

export fn B_constPtrMulti_offset() usize {
    return @offsetOf(B, "constPtrMulti");
}

export fn B_constPtrMulti_size() usize {
    return @sizeOf([*]const u8);
}

export fn B_constPtrMultiSentinel_align() usize {
    return @alignOf([*:255]const u8);
}

export fn B_constPtrMultiSentinel_offset() usize {
    return @offsetOf(B, "constPtrMultiSentinel");
}

export fn B_constPtrMultiSentinel_size() usize {
    return @sizeOf([*:255]const u8);
}

export fn B_array_align() usize {
    return @alignOf([2]i32);
}

export fn B_array_offset() usize {
    return @offsetOf(B, "array");
}

export fn B_array_size() usize {
    return @sizeOf([2]i32);
}

export fn B_arraySentinel_align() usize {
    return @alignOf([2:0]i32);
}

export fn B_arraySentinel_offset() usize {
    return @offsetOf(B, "arraySentinel");
}

export fn B_arraySentinel_size() usize {
    return @sizeOf([2:0]i32);
}

export fn B_aSingle_align() usize {
    return @alignOf(A);
}

export fn B_aSingle_offset() usize {
    return @offsetOf(B, "aSingle");
}

export fn B_aSingle_size() usize {
    return @sizeOf(A);
}

export fn B_aSlice_align() usize {
    return @alignOf(ASlice);
}

export fn B_aSlice_offset() usize {
    return @offsetOf(B, "aSlice");
}

export fn B_aSlice_size() usize {
    return @sizeOf(ASlice);
}

export fn B_constASlice_align() usize {
    return @alignOf(ConstASlice);
}

export fn B_constASlice_offset() usize {
    return @offsetOf(B, "constASlice");
}

export fn B_constASlice_size() usize {
    return @sizeOf(ConstASlice);
}

export fn B_aPtr_align() usize {
    return @alignOf(*A);
}

export fn B_aPtr_offset() usize {
    return @offsetOf(B, "aPtr");
}

export fn B_aPtr_size() usize {
    return @sizeOf(*A);
}

export fn B_aPtr2_align() usize {
    return @alignOf(*[2]A);
}

export fn B_aPtr2_offset() usize {
    return @offsetOf(B, "aPtr2");
}

export fn B_aPtr2_size() usize {
    return @sizeOf(*[2]A);
}

export fn B_aPtrMulti_align() usize {
    return @alignOf([*]A);
}

export fn B_aPtrMulti_offset() usize {
    return @offsetOf(B, "aPtrMulti");
}

export fn B_aPtrMulti_size() usize {
    return @sizeOf([*]A);
}
"
`;
